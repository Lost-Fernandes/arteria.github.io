<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>rPPG Debug — Medidor de Batimentos</title>

  <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: blob:; script-src 'self' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline'; connect-src 'self' https://*; media-src 'self' blob:; img-src 'self' data:;">

  <style>
    :root{--bg:#0d1117;--card:#161b22;--accent:#2196F3;--text:#e6edf3;--muted:#768390;--plot:#0f1419}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:var(--text);background:linear-gradient(180deg,var(--bg),#0a0d13)}
    .wrap{max-width:980px;margin:36px auto;padding:20px}
    .card{background:var(--card);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.04)}
    .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    select,button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    button{background:var(--accent);color:#042a30;font-weight:700;cursor:pointer}
    button.secondary{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,0.04)}
    .bpm{font-size:48px;font-weight:800}
    #plot{width:100%;height:160px;background:var(--plot);border-radius:10px;margin-top:8px}
    .status{margin-top:12px;color:var(--muted)}
    .debug{margin-top:12px;padding:10px;border-radius:8px;background:#1b2228;color:#f1c40f;font-family:monospace;white-space:pre-wrap}
    .small{color:var(--muted);font-size:13px}
    .video-hidden{display:none}
  </style>

  <!-- jsPDF (only for PDF export) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1 style="color:var(--accent)">Protótipo rPPG — Debug</h1>
    <p class="small">Use Live Server / http-server. Se algo falhar, copie o texto do painel <strong>Último erro</strong> e cole aqui.</p>

    <div class="card">
      <div class="controls">
        <label>
          Método:
          <select id="method">
            <option value="finger">Dedo</option>
            <option value="face">Rosto</option>
          </select>
        </label>

        <button id="startBtn">Iniciar</button>
        <button id="stopBtn" class="secondary" disabled>Parar</button>

        <button id="calibrateBtn" class="secondary">Calibrar</button>
        <button id="exportCsvBtn" class="secondary">Exportar CSV</button>
        <button id="exportPdfBtn" class="secondary">Gerar PDF</button>
      </div>

      <div style="display:flex;gap:16px;align-items:center;margin-top:12px">
        <div>
          <div class="bpm" id="bpm">--</div>
          <div class="small">BPM estimado</div>
        </div>
        <div style="flex:1">
          <canvas id="plot"></canvas>
        </div>
      </div>

      <div class="status">
        Taxa amostragem (Hz): <span id="samplerate">--</span> — Janela (s): <span id="bufferSec">8</span> — Calib: <span id="calibInfo">Nenhuma</span>
      </div>

      <p class="small" style="margin-top:12px">Dicas: para testar, cubra levemente a lente com o dedo e mantenha imóvel. Aguarde ~10s para aparecer BPM.</p>

      <div class="debug" id="debugBox">Último erro: nenhum</div>
    </div>

    <!-- hidden capture elements -->
    <video id="video" autoplay playsinline class="video-hidden"></video>
    <canvas id="capture" class="video-hidden"></canvas>
  </div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  // debug helper
  const debugBox = document.getElementById('debugBox');
  function debugLog(msg){
    console.error(msg);
    debugBox.textContent = 'Último erro:\\n' + (typeof msg === 'string' ? msg : (msg && msg.stack ? msg.stack : JSON.stringify(msg)));
  }

  try{
    // DOM refs
    const bufferSec = 8;
    const minHR = 40, maxHR = 200;

    const video = document.getElementById('video');
    const capture = document.getElementById('capture');
    const plot = document.getElementById('plot');
    const ctx = capture.getContext ? capture.getContext('2d') : null;
    const plotCtx = plot.getContext('2d');

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const calibrateBtn = document.getElementById('calibrateBtn');
    const exportCsvBtn = document.getElementById('exportCsvBtn');
    const exportPdfBtn = document.getElementById('exportPdfBtn');
    const bpmEl = document.getElementById('bpm');
    const samplerateEl = document.getElementById('samplerate');
    const bufferEl = document.getElementById('bufferSec');
    const calibInfo = document.getElementById('calibInfo');
    const methodSelect = document.getElementById('method');

    bufferEl.textContent = bufferSec;

    let stream = null, running = false;
    let samples = [], timestamps = [];
    let bpmHistory = [];
    let logs = [];
    let wakeLock = null;
    let calib = null;
    try{ calib = JSON.parse(localStorage.getItem('rppg_calib') || 'null'); }catch(e){ calib = null; }
    if (calib) calibInfo.textContent = `Offset: ${calib.offset.toFixed(1)} bpm (salvo)`;

    const motionThreshold = 18;
    let lastFrameGray = null;

    // safe event bind
    startBtn.addEventListener('click', ()=>{ try{ start(); }catch(e){ debugLog(e); }});
    stopBtn.addEventListener('click', ()=>{ try{ stop(); }catch(e){ debugLog(e); }});
    calibrateBtn.addEventListener('click', ()=>{ try{ calibrate(); }catch(e){ debugLog(e); }});
    exportCsvBtn.addEventListener('click', ()=>{ try{ exportCsv(); }catch(e){ debugLog(e); }});
    exportPdfBtn.addEventListener('click', ()=>{ try{ exportPdf(); }catch(e){ debugLog(e); }});

    async function start(){
      if (running) return;
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        alert('Navegador não suporta getUserMedia. Use Chrome/Edge/Firefox ou teste no celular.');
        return;
      }
      try{
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } }, audio:false });
        video.srcObject = stream;
        running = true;
        startBtn.disabled = true; stopBtn.disabled = false;
        samples = []; timestamps = []; bpmHistory = []; logs = []; lastFrameGray = null;
        // wake lock (optional)
        if ('wakeLock' in navigator){
          try{ wakeLock = await navigator.wakeLock.request('screen'); }catch(e){ console.warn('WakeLock:', e); }
        }
        requestAnimationFrame(processFrame);
      }catch(err){
        debugLog('Erro getUserMedia: ' + (err && err.message ? err.message : String(err)));
        alert('Erro ao acessar câmera: ' + (err && err.message ? err.message : String(err)));
      }
    }

    function stop(){
      running = false;
      startBtn.disabled = false; stopBtn.disabled = true;
      if (stream) stream.getTracks().forEach(t=>t.stop());
      stream = null;
      bpmEl.textContent = '--';
      clearPlot();
      if (wakeLock){ try{ wakeLock.release(); }catch(e){ } wakeLock = null; }
    }

    function processFrame(){
      try{
        if (!running) return;
        if (video.readyState < 2){ requestAnimationFrame(processFrame); return; }
        if (!ctx || !plotCtx) { debugLog('Canvas 2D não suportado'); return; }

        const w = 160, h = 120;
        capture.width = w; capture.height = h;
        ctx.drawImage(video, 0, 0, w, h);

        const method = methodSelect.value;
        let roi = { x: Math.floor(w*0.25), y: Math.floor(h*0.25), w: Math.floor(w*0.5), h: Math.floor(h*0.5) };
        if (method === 'face') roi = { x: Math.floor(w*0.2), y: Math.floor(h*0.15), w: Math.floor(w*0.6), h: Math.floor(h*0.6) };

        const img = ctx.getImageData(roi.x, roi.y, roi.w, roi.h);
        const data = img.data;

        let sumG = 0, cnt = 0;
        const gray = new Uint8ClampedArray(roi.w * roi.h);
        let gi = 0;
        for (let i=0;i<data.length;i+=4){
          const r = data[i], g = data[i+1], b = data[i+2];
          sumG += g;
          gray[gi++] = (0.299*r + 0.587*g + 0.114*b);
          cnt++;
        }
        const meanG = sumG / Math.max(1, cnt);
        const now = performance.now()/1000.0;

        // motion RMS
        let motion = 0;
        if (lastFrameGray && lastFrameGray.length === gray.length){
          let s = 0;
          for (let i=0;i<gray.length;i++){ const d = gray[i] - lastFrameGray[i]; s += d*d; }
          motion = Math.sqrt(s/gray.length);
        }
        lastFrameGray = gray;

        if (motion > motionThreshold){
          logs.push({time:new Date().toISOString(), bpm:null, source:'motion', motion});
          samplerateEl.textContent = '-- (motion)';
          requestAnimationFrame(processFrame);
          return;
        }

        samples.push(meanG); timestamps.push(now);
        while (timestamps.length > 0 && (now - timestamps[0]) > bufferSec){ timestamps.shift(); samples.shift(); }

        const fs = estimateFs(timestamps);
        samplerateEl.textContent = fs? fs.toFixed(1): '--';

        drawPlot(samples);

        const bpm = estimateBPM(samples, timestamps);
        if (bpm){
          const adjusted = calib ? (bpm + calib.offset) : bpm;
          bpmHistory.push(adjusted);
          if (bpmHistory.length > 5) bpmHistory.shift();
          const med = median(bpmHistory.slice(-3));
          bpmEl.textContent = Math.round(med);
          logs.push({time:new Date().toISOString(), bpm:Math.round(med), source:'rPPG'});
        }

        requestAnimationFrame(processFrame);
      }catch(e){
        debugLog(e);
      }
    }

    function estimateFs(ts){
      if (!ts || ts.length < 2) return 0;
      const diffs = [];
      for (let i=1;i<ts.length;i++) diffs.push(ts[i]-ts[i-1]);
      const mean = diffs.reduce((a,b)=>a+b,0)/diffs.length;
      return 1.0/mean;
    }

    function clearPlot(){ if (!plotCtx) return; plotCtx.clearRect(0,0,plot.width,plot.height); }

    function drawPlot(samples){
      if (!plotCtx) return;
      plot.width = plot.clientWidth * devicePixelRatio;
      plot.height = plot.clientHeight * devicePixelRatio;
      plotCtx.clearRect(0,0,plot.width,plot.height);
      if (!samples || samples.length === 0) return;
      const vals = samples.slice();
      const min = Math.min(...vals), max = Math.max(...vals);
      const range = (max-min) || 1;
      plotCtx.lineWidth = 2 * devicePixelRatio;
      plotCtx.beginPath();
      for (let i=0;i<vals.length;i++){
        const x = (i/(vals.length-1))*(plot.width - 8*devicePixelRatio) + 4*devicePixelRatio;
        const y = plot.height - ((vals[i]-min)/range)*(plot.height - 8*devicePixelRatio) - 4*devicePixelRatio;
        if (i===0) plotCtx.moveTo(x,y); else plotCtx.lineTo(x,y);
      }
      plotCtx.strokeStyle = '#60a5fa';
      plotCtx.stroke();
    }

    function median(arr){ if (!arr || arr.length===0) return null; const s = arr.slice().sort((a,b)=>a-b); const m = Math.floor(s.length/2); return s.length%2 ? s[m] : (s[m-1]+s[m])/2; }

    function estimateBPM(samples, timestamps){
      if (!samples || samples.length < 48) return null;
      const fs = estimateFs(timestamps);
      if (!fs || fs < 4) return null;
      const t0 = timestamps[0];
      const dt = 1.0/fs;
      const n = Math.floor((timestamps[timestamps.length-1] - t0) * fs);
      if (n < 64) return null;
      const uniform = new Float32Array(n);
      for (let i=0;i<n;i++){
        const ti = t0 + i*dt;
        let j = 0;
        while (j < timestamps.length-1 && timestamps[j+1] < ti) j++;
        const tA = timestamps[j];
        const tB = timestamps[Math.min(j+1, timestamps.length-1)];
        const vA = samples[j];
        const vB = samples[Math.min(j+1, samples.length-1)];
        const v = (tB === tA) ? vA : (vA + (vB-vA)*((ti-tA)/(tB-tA)));
        uniform[i] = v;
      }

      const mean = uniform.reduce((a,b)=>a+b,0)/uniform.length;
      for (let i=0;i<uniform.length;i++) uniform[i] -= mean;
      for (let i=0;i<uniform.length;i++){ const w = 0.54 - 0.46 * Math.cos(2*Math.PI*i/(uniform.length-1)); uniform[i] *= w; }

      const spec = rfft(uniform, fs);
      if (!spec || spec.length === 0) return null;
      const minF = minHR/60.0, maxF = maxHR/60.0;
      let best = {f:0, mag:0};
      for (const p of spec){ if (p.f < minF || p.f > maxF) continue; if (p.mag > best.mag) best = p; }
      if (best.mag <= 0) return null;
      return best.f * 60.0;
    }

    // FFT helpers
    function rfft(signal, fs){
      let n0 = signal.length, n=1;
      while (n < n0) n <<= 1;
      if (n > 16384) n = 16384;
      const re = new Float32Array(n), im = new Float32Array(n);
      re.set(signal.subarray(0, Math.min(signal.length, n)));
      fft(re, im);
      const out = []; const df = fs / n;
      for (let k=1;k<Math.floor(n/2);k++){ const mag = Math.sqrt(re[k]*re[k] + im[k]*im[k]); out.push({f:k*df, mag}); }
      return out;
    }
    function fft(re, im){
      const n = re.length;
      let j = 0;
      for (let i=1;i<n;i++){
        let bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j){
          let tr = re[i]; re[i] = re[j]; re[j] = tr;
          let ti = im[i]; im[i] = im[j]; im[j] = ti;
        }
      }
      for (let len=2; len<=n; len<<=1){
        const ang = -2*Math.PI/len, wlen_r = Math.cos(ang), wlen_i = Math.sin(ang);
        for (let i=0;i<n;i+=len){
          let wr = 1, wi = 0;
          for (let j=0;j<len/2;j++){
            const u_r = re[i+j], u_i = im[i+j];
            const v_r = re[i+j+len/2]*wr - im[i+j+len/2]*wi;
            const v_i = re[i+j+len/2]*wi + im[i+j+len/2]*wr;
            re[i+j] = u_r + v_r; im[i+j] = u_i + v_i;
            re[i+j+len/2] = u_r - v_r; im[i+j+len/2] = u_i - v_i;
            const tmp_r = wr * wlen_r - wi * wlen_i;
            wi = wr * wlen_i + wi * wlen_r;
            wr = tmp_r;
          }
        }
      }
    }

    // calibration, csv, pdf (kept simple)
    function calibrate(){
      try{
        const val = prompt('Calibração: digite BPM de referência (ex: leitura do aparelho):');
        if (!val) return;
        const ref = Number(val);
        if (isNaN(ref) || ref <= 0){ alert('Valor inválido'); return; }
        const recent = bpmHistory.length ? bpmHistory[bpmHistory.length-1] : null;
        if (!recent){ alert('Sem leituras recentes para calibrar. Inicie o medidor primeiro.'); return; }
        const offset = ref - recent;
        calib = {offset, date:new Date().toISOString()};
        try{ localStorage.setItem('rppg_calib', JSON.stringify(calib)); }catch(e){}
        calibInfo.textContent = `Offset: ${offset.toFixed(1)} bpm (salvo)`;
        alert('Calibração salva.');
      }catch(e){ debugLog(e); }
    }

    function exportCsv(){
      try{
        if (!logs || logs.length===0){ alert('Sem logs para exportar'); return; }
        const header = ['time','bpm','source','motion'];
        const rows = logs.map(r => [r.time, r.bpm===null?'':r.bpm, r.source||'', r.motion||'']);
        const csv = [header.join(','), ...rows.map(r => r.map(c => '"' + String(c).replace(/"/g,'""') + '"').join(','))].join('\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `rppg_logs_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.csv`; a.click();
        URL.revokeObjectURL(url);
      }catch(e){ debugLog(e); }
    }

    async function exportPdf(){
      try{
        if (!logs || logs.length===0){ alert('Sem dados para gerar PDF'); return; }
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({orientation:'portrait', unit:'pt', format:'a4'});
        doc.setFontSize(14); doc.text('Relatório rPPG', 40, 50);
        doc.setFontSize(11); doc.text(`Data: ${new Date().toLocaleString()}`, 40, 70);
        const bpms = logs.filter(l=>l.bpm).map(l=>l.bpm);
        const avg = bpms.length ? (bpms.reduce((a,b)=>a+b,0)/bpms.length).toFixed(1) : 'N/A';
        const min = bpms.length ? Math.min(...bpms) : 'N/A';
        const max = bpms.length ? Math.max(...bpms) : 'N/A';
        doc.text(`Média BPM: ${avg}`, 40, 100); doc.text(`Min: ${min} | Máx: ${max}`, 40, 116);
        if (calib) doc.text(`Calibração: offset ${calib.offset.toFixed(1)} bpm`, 40, 132);
        const imgData = plot.toDataURL('image/png',1.0);
        doc.addImage(imgData, 'PNG', 40, 160, 520, 180);
        doc.save(`rppg_report_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.pdf`);
      }catch(e){ debugLog(e); }
    }

    // cleanup
    window.addEventListener('beforeunload', ()=>{ try{ if (stream) stream.getTracks().forEach(t=>t.stop()); }catch(e){} if (wakeLock){ try{ wakeLock.release(); }catch(e){} wakeLock=null; } });

  }catch(e){
    // fatal init error
    const debugBox = document.getElementById('debugBox');
    debugBox.textContent = 'Init failed:\\n' + (e && e.stack ? e.stack : String(e));
    console.error(e);
  }
});
</script>
</body>
</html>
