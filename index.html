<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Medidor de Batimentos Cardíacos</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0f172a;
      color: #fff;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    h2 { color: #60a5fa; }
    video, canvas {
      margin-top: 10px;
      border-radius: 12px;
      background: #000;
      max-width: 90%;
    }
    button {
      margin: 6px;
      padding: 10px 14px;
      border: none;
      border-radius: 6px;
      background-color: #2563eb;
      color: #fff;
      cursor: pointer;
      transition: 0.2s;
    }
    button:hover { background-color: #1d4ed8; }
    button:disabled {
      background: #444;
      cursor: not-allowed;
    }
    #bpm {
      font-size: 28px;
      color: #22c55e;
      margin: 10px;
    }
    #debugBox {
      margin-top: 10px;
      padding: 6px;
      font-size: 13px;
      color: #fca5a5;
      white-space: pre-line;
    }
    select {
      padding: 6px;
      border-radius: 5px;
      border: 1px solid #ccc;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h2>Medidor de Batimentos Cardíacos (Protótipo)</h2>
  <label for="method">Método:</label>
  <select id="method">
    <option value="finger">Dedo (recomendado)</option>
    <option value="face">Rosto</option>
  </select>

  <div>
    <video id="video" autoplay playsinline width="320" height="240"></video><br>
    <canvas id="capture" width="160" height="120" hidden></canvas>
    <canvas id="plot" width="320" height="100"></canvas>
  </div>

  <div>
    <button id="startBtn">Iniciar</button>
    <button id="stopBtn" disabled>Parar</button>
    <button id="calibrateBtn">Calibrar</button>
    <button id="exportCsvBtn">Exportar CSV</button>
    <button id="exportPdfBtn">Exportar PDF</button>
  </div>

  <div id="bpm">--</div>
  <div>Taxa de amostragem: <span id="samplerate">--</span> Hz</div>
  <div>Buffer: <span id="bufferSec"></span> s</div>
  <div id="calibInfo"></div>
  <div id="debugBox"></div>

  <script>
    const video = document.getElementById("video");
    const captureCanvas = document.getElementById("capture");
    const plotCanvas = document.getElementById("plot");
    const ctx = captureCanvas.getContext("2d");
    const plotCtx = plotCanvas.getContext("2d");
    const bpmElem = document.getElementById("bpm");
    const samplerateElem = document.getElementById("samplerate");
    const bufferSecElem = document.getElementById("bufferSec");
    const debugBox = document.getElementById("debugBox");
    const calibInfo = document.getElementById("calibInfo");

    let stream, animationId;
    let samples = [];
    let timestamps = [];
    let running = false;
    let calibration = null;
    let motionThreshold = 5;
    let fps = 0;
    let userCalib = { min: 0, max: 255 };

    function log(msg) {
      debugBox.textContent = msg;
    }

    async function startCamera() {
      const method = document.getElementById("method").value;
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: method === "face" ? "user" : "environment" }
        });
        video.srcObject = stream;
        running = true;
        measure();
      } catch (err) {
        log("Erro ao acessar câmera: " + err.message);
      }
    }

    function stopCamera() {
      running = false;
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      cancelAnimationFrame(animationId);
      log("Medição parada.");
    }

    function averageBrightness(frame) {
      const data = frame.data;
      let sum = 0;
      for (let i = 0; i < data.length; i += 4) sum += data[i];
      return sum / (data.length / 4);
    }

    function measure() {
      const now = performance.now();
      ctx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
      const frame = ctx.getImageData(0, 0, captureCanvas.width, captureCanvas.height);
      const bright = averageBrightness(frame);

      if (!calibration) {
        calibration = { last: bright };
        timestamps = [];
        samples = [];
      }

      const diff = Math.abs(bright - calibration.last);
      if (diff > motionThreshold) {
        calibration.last = bright;
      }

      samples.push(bright);
      timestamps.push(now);

      if (timestamps.length > 2) {
        const dt = (timestamps[timestamps.length - 1] - timestamps[0]) / 1000;
        fps = timestamps.length / dt;
        samplerateElem.textContent = fps.toFixed(1);
        bufferSecElem.textContent = dt.toFixed(1);
      }

      drawPlot();

      if (samples.length > 150) {
        detectBpm();
        samples.shift();
        timestamps.shift();
      }

      if (running) animationId = requestAnimationFrame(measure);
    }

    function detectBpm() {
      const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
      const normalized = samples.map(v => v - mean);
      let peaks = 0;
      for (let i = 1; i < normalized.length - 1; i++) {
        if (normalized[i] > 0 && normalized[i] > normalized[i - 1] && normalized[i] > normalized[i + 1]) peaks++;
      }
      const duration = (timestamps[timestamps.length - 1] - timestamps[0]) / 1000 / 60;
      const bpm = (peaks / duration).toFixed(0);
      bpmElem.textContent = bpm + " BPM";
    }

    function drawPlot() {
      plotCtx.fillStyle = "#0f172a";
      plotCtx.fillRect(0, 0, plotCanvas.width, plotCanvas.height);
      plotCtx.beginPath();
      plotCtx.strokeStyle = "#22c55e";
      const scaleX = plotCanvas.width / samples.length;
      const min = Math.min(...samples);
      const max = Math.max(...samples);
      const range = max - min || 1;
      for (let i = 0; i < samples.length; i++) {
        const y = plotCanvas.height - ((samples[i] - min) / range) * plotCanvas.height;
        if (i === 0) plotCtx.moveTo(0, y);
        else plotCtx.lineTo(i * scaleX, y);
      }
      plotCtx.stroke();
    }

    document.getElementById("startBtn").onclick = () => {
      startCamera();
      document.getElementById("startBtn").disabled = true;
      document.getElementById("stopBtn").disabled = false;
    };

    document.getElementById("stopBtn").onclick = () => {
      stopCamera();
      document.getElementById("startBtn").disabled = false;
      document.getElementById("stopBtn").disabled = true;
    };

    document.getElementById("calibrateBtn").onclick = () => {
      if (samples.length) {
        userCalib.min = Math.min(...samples);
        userCalib.max = Math.max(...samples);
        calibInfo.textContent = `Calibração feita: min=${userCalib.min.toFixed(1)}, max=${userCalib.max.toFixed(1)}`;
      }
    };

    document.getElementById("exportCsvBtn").onclick = () => {
      let csv = "timestamp,brightness\\n";
      for (let i = 0; i < samples.length; i++) {
        csv += `${timestamps[i]},${samples[i]}\\n`;
      }
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "dados_batimentos.csv";
      a.click();
      URL.revokeObjectURL(url);
    };

    document.getElementById("exportPdfBtn").onclick = async () => {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
      doc.text("Relatório de Batimentos Cardíacos", 20, 20);
      doc.text(`BPM Atual: ${bpmElem.textContent}`, 20, 30);
      doc.text(`Taxa de Amostragem: ${fps.toFixed(1)} Hz`, 20, 40);
      doc.text(`Tempo de Amostragem: ${bufferSecElem.textContent}s`, 20, 50);
      doc.save("relatorio_batimentos.pdf");
    };
  </script>
</body>
</html>

